--CREATE OR REPLACE VIEW

CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPT;

CREATE TABLE EMP_COPY
AS
SELECT * FROM EMP;

CREATE VIEW EMP_VIEW30
AS SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30;

--VIEW는 실제 데이터가 아닌 AS이후의 쿼리문을 저장하고있는것 뿐이다.

SELECT * FROM EMP_VIEW30;
DESC EMP_VIEW30;

--VIEW 에 저장된 TEXT 쿼리문을 알아보자

SELECT VIEW_NAME, TEXT
FROM USER_VIEWS; --TEXT에 해당 쿼리문이 저장되어있다.(서브쿼리형태로 동작하는것이다)


INSERT INTO EMP_VIEW30
VALUES(1111,'AAAA',30);

SELECT * FROM EMP_VIEW30; --VIEW에는 당연히 저장되어있다.
SELECT * FROM EMP_COPY; --VIEW를 만들었던 기존 테이블도 데이터가 삽입되어있다.(이 기능으로 여러 사용자에게 접근범위을 제한할수있다)

CREATE OR REPLACE
VIEW EMP_VIEW(사원번호,사원명,급여,부서번호) --컬럼별칭 지정
AS SELECT EMPNO,ENAME,SAL,DEPTNO
FROM EMP_COPY;

SELECT * FROM EMP_VIEW 
WHERE "부서번호"=20; --컬럼 명

--가상컬럼 생성시 VIEW 는 반드시 별칭을 지정해야한다. 
--VIEW는 기본테이블의 가상컬럼을 상속할수가 없다.
CREATE VIEW VIEW_SAL
AS
SELECT DEPTNO, SUM(SAL) AS "SALSUM", 
		AVG(SAL) AS "SALAVG"
		FROM EMP_COPY
		GROUP BY DEPTNO;
		
SELECT * FROM VIEW_SAL;

--기본적으로 VIEW 의 INSERT는 NULL을 허용해야만 작동한다. 컬럼에 NOT NULL이 설정되어있으면
--사용할 수 없다.


--복합 뷰~
--JOIN된 테이블에 관한 뷰
--중요해 보인다.

CREATE VIEW EMP_VIEW_DEPT
AS 
SELECT  E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
ORDER BY EMPNO DESC; --EMPNO 역순정렬
--두 테이블을 조인한 뷰를 만들었다.

SELECT * FROM EMP_VIEW_DEPT;

CREATE OR REPLACE VIEW SAL_VIEW
AS
SELECT DEPT.DNAME, MIN(SAL) "MIN_SAL", MAX(SAL) "MAX_SAL"
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO
GROUP BY DNAME;

SELECT * FROM SAL_VIEW;
--WITH CHECK OPTION 제약
CREATE OR REPLACE VIEW VIEW_CHK30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH CHECK OPTION;
--DEPTNO=30이 CHECK OPTION이다.
SELECT * FROM VIEW_CHK30;

UPDATE VIEW_CHK30 SET DEPTNO=20
WHERE SAL>=500;
--CHECK OPTION에 위배됨
SELECT *
FROM USER_VIEWS;


--WITH READ ONLY
--읽기만 가능하다. 수정은 불가하다.
CREATE OR REPLACE VIEW VIEW_READ30
AS
SELECT EMPNO,ENAME,SAL,COMM,DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH READ ONLY;

UPDATE VIEW_READ30  SET COMM=3000; --READ ONLY 에러

--ROW NUM 확인
SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM EMP;

SELECT ROWNUM, EMPNO,ENAME,HIREDATE
FROM EMP
ORDER BY HIREDATE;

--ROW NUM데이터는 이미 존재하기 때문에 ORDER BY를 추가하면 순서가 일정해 지지 않는다.
--오라클에서 내부적으로 부여되어있다. 값이 이미 지정되어있으므로 바뀌지않는다.
--정렬된 순서대로 매겨지게 하고싶다면 새로운 VIEW를 생성해야한다.

--INLINE VIEW
--뷰를 생성할때 VIEW의 ROWNUM은 정의 된다.
CREATE OR REPLACE VIEW VIEW_HIRE
AS
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY HIREDATE;
--SORTING
SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM VIEW_HIRE
WHERE ROWNUM<=5;
--TOP 5;
--두번의 쿼리를  작성했다. 이걸 하나로 합친다면..
--VIEW를 만들면 새로운 ROWNUM이 부여된다.
--FROM에 서브쿼리를 삽입해서 테이블 처럼 이용해봅세다 이것이 INLINE VIEW

SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM (SELECT ROWNUM AS RNUM, EMPNO, ENAME, HIREDATE
	FROM (SELECT EMPNO, ENAME,HIREDATE
		FROM EMP
		ORDER BY HIREDATE)
	WHERE ROWNUM<=10) --여기서 VIEW가 생성되면서 새로운 ROWNUM이 생성된다.
--인라인 뷰의 패턴. 게시판 페이지 이동시 요 기법을 사용한다(페이지별 컬럼갯수 단위로 페이지 이동)
WHERE RNUM>=5 ; --거기서 TOP-5
--SUBQUERY를 두개 넣으면 BETWEEN 효과를 가질 수도 있다. 단 첫번째 서브쿼리의 ROWNUM은 별칭으로 이름을 바꿔사용해야한다.(새로운 컬럼 하나 만듬)

--문제
SELECT ROWNUM AS RANGKING, EMPNO, ENAME, SAL
FROM(SELECT ROWNUM, EMPNO,ENAME, SAL
	FROM EMP
	ORDER BY SAL DESC)
	WHERE ROWNUM<=3;
