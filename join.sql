select *
from emp,dept;
--cross join T1* T2 
--큰 의미없는 조인

SELECT *
FROM EMP,DEPT
WHERE ENAME='SCOTT';

--EQUI JOIN
--두 테이블에 존재하는 F KEY로 일치되는 행을 연결하는 방법
SELECT *
FROM EMP,DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO;
--해당 테이블에 .으로 컬럼을 구분(규정자)

SELECT EMP.EMPNO,EMP.ENAME,EMP.DEPTNO,DEPT.DNAME 
FROM EMP,DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO
AND ENAME='SCOTT';
--쿼리 하나로 두개의 테이블에서 원하는 값을 구했다.
--주의!!!! 두 테이블에 공통으로 들어가는 컬럼명은 반드시 구분해야 한다. 

--별칭 만들기

SELECT E.NAME, D.DNAME, E.DEPTNO, D.DEPTNO
FROM EMP  E, DEPT  D
WHERE E.DEPTNO = D.DEPTNO
AND E.ENAME='SCOTT';

--뉴욕사원
SELECT ENAME, SAL
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO
AND DEPT.LOC='NEW YORK';

--ACCOUNTING 부서 

SELECT ENAME,HIREDATE
FROM EMP,DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND DEPT.DNAME='ACCOUNTING';

--매니져
SELECT ENAME,DEPT.DNAME
FROM EMP,DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND EMP.JOB='MANAGER';

--NON EQUI JOIN

SELECT ENAME, SAL, GRADE, LOSAL,HISAL
FROM EMP,SALGRADE
WHERE SAL>=SALGRADE.LOSAL AND SAL<=HISAL;
--부등호를 사용한 JOIN 이 NOT EQUI JOIN


--SELF JOIN 예제 
--MGR은 사원번호다. 해당 사원번호를 가진 상사를 구해보자
--한 테이블에서 값을 비교해서 찾아야하는 경우
SELECT ENAME, MGR
FROM EMP
WHERE ENAME='SMITH';

SELECT EMPNO, ENAME
FROM EMP
WHERE EMPNO=7902;
--두개의 쿼리문을 사용했다.
--SELF JOIN
SELECT E1.ENAME ||'의 매니저는'|| E2.ENAME ||'입니다'
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO --상사가 누구지
AND E1.ENAME='SMITH'; --스미스만 
--하나의 테이블에 별칭을 두개 만들어서 값을 비교해본다.

SELECT E1.ENAME,E1.JOB
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO
AND E2.ENAME='KING';

SELECT E1.ENAME, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.DEPTNO= E2.DEPTNO
AND E1.ENAME='SCOTT';
--AND E2.ENAME<>'SCOTT';

SELECT *
FROM EMP
WHERE DEPTNO=20;


--OUTER JOIN
--(+)기호로 나타내며 매칭이 되지 않은 정보까지 보여준다.
SELECT E.ENAME ||'의 매니저는'||E2.ENAME||'입니다'
FROM EMP E, EMP E2
WHERE E.MGR =E2.EMPNO(+);


SELECT EMP.ENAME, DEPT.DEPTNO, DEPT.DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO(+)=DEPT.DEPTNO
ORDER BY DEPT.DEPTNO;


--ANSI 구문들
--공통 으로 쿼리에서 사용되는 JOIN문들..
--CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;

--INNER JOIN

SELECT ENAME, DNAME
FROM EMP INNER JOIN DEPT
ON EMP.DEPTNO=DEPT.DEPTNO --ON절에 조인 조건을 담는다. WHERE 에는 나머지 다른 조건을 지정하면된다.
WHERE ENAME ='SCOTT';

--ON 에 공통 필드가 올 경우 USING 사용

SELECT ENAME, DNAME
FROM EMP INNER JOIN DEPT
USING (DEPTNO) --별칭말고 두 테이블의 공통필드명을 괄호안에 넣는다.
WHERE ENAME = 'SCOTT';

--NATURAL JOIN 
--공통컬럼을 알아서 찾아 조인해준다.
--
SELECT *
FROM EMP NATURAL JOIN DEPT
ORDER BY DEPTNO;


--OUTER JOIN

DROP TABLE DEPT01;

CREATE TABLE DEPT01(
DEPTNO NUMBER(2),
DNAME VARCHAR(14));

DESC DEPT01;

SELECT *
FROM DEPT01;

INSERT INTO DEPT01(DEPTNO,DNAME) VALUES(10,'ACCOUNTING'); -- 모든필드에 데이터 입력할 경우 테이블 이름앞에 필드명은 생략가능하다
INSERT INTO DEPT01 VALUES(20,'RESERCH');

CREATE TABLE DEPT02(
DEPTNO NUMBER(2),
DNAME VARCHAR2(14));

INSERT INTO DEPT02 VALUES(10,'ACCOUNTING');
INSERT INTO DEPT02 VALUES(30,'SALES');

SELECT *
FROM DEPT02;

SELECT *
FROM DEPT01,DEPT02
WHERE DEPT01.DEPTNO = DEPT02.DEPTNO(+);

SELECT *
FROM DEPT01 LEFT OUTER JOIN DEPT02
ON DEPT01.DEPTNO = DEPT02.DEPTNO;

SELECT *
FROM DEPT01 RIGHT OUTER JOIN DEPT02
USING(DEPTNO);

--서브 쿼리
-- 서브쿼리는 SELECT 키워드 내의 다른 SELECT 문
--서브쿼리는 메인 쿼리 실행전에 단 한번만 실행된다.

--단일행 서브쿼리 필드=값하나
SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO=(SELECT DEPTNO
                        FROM EMP
                        WHERE ENAME='SCOTT' )
	 AND NOT ENAME='SCOTT';

SELECT *
FROM EMP
WHERE JOB=(SELECT JOB
                    FROM EMP
                    WHERE ENAME='SCOTT');
--SCOTT과 급여가 동일하거나 많은경우
SELECT *
FROM EMP
WHERE SAL>=(SELECT SAL
                      FROM EMP
                      WHERE ENAME='SCOTT');
                      
--DALLAS에서 근무하는 사원이름 부서번호
SELECT EMP.ENAME,EMP.DEPTNO
FROM EMP
WHERE EMP.DEPTNO=(SELECT DEPTNO
                          FROM DEPT
                          WHERE LOC='DALLAS');

--SALES부서 급여 이름 출력
SELECT ENAME, SAL
FROM EMP
WHERE DEPTNO=(SELECT DEPTNO
                          FROM DEPT
                          WHERE DNAME='SALES');
--상관(MGR)이 KING인 사람들 출력		      
SELECT ENAME, SAL
FROM EMP
WHERE MGR=(SELECT EMPNO --쉽게 말해 저 필드와 비교할 값을 여기서 셀렉트 한다.(단일값)
		      FROM EMP
		      WHERE ENAME='KING');
		      
--그룹함수는 단일 행이기 때문에(한개의 값) 서브쿼리 가능
SELECT ENAME , SAL
FROM EMP
WHERE SAL>(SELECT AVG(SAL)
		FROM EMP);
SELECT AVG(SAL)
FROM EMP;

--다중행 서브쿼리
--비교할 결과값이 하나 이상일경우에
--IN(하나라도 일치), ALL(모두), ANY(하나이상)...


--IN
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN(SELECT DISTINCT DEPTNO
			FROM EMP
			WHERE SAL>=3000);

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
		FROM EMP
		GROUP BY DEPTNO);

SELECT DEPTNO, DNAME, LOC
FROM DEPT
WHERE DEPTNO IN (SELECT DEPTNO
		FROM EMP
		WHERE JOB='MANAGER');
		
-- ALL
SELECT ENAME, SAL
FROM EMP
WHERE SAL >(SELECT MAX(SAL) 
			FROM EMP
			WHERE DEPTNO=30);
--그룹함수로 30번 부서의 맥스를 구해주거나			
SELECT ENAME, SAL
FROM EMP
WHERE SAL > ALL   (SELECT SAL
			FROM EMP
			WHERE DEPTNO=30);
			
-- ALL은 모든 결과가 참일때 참이다. 30번 부서의 SAL을 모두 대입했을때	그보다 큰사람들만 참으로 출력된다.

--ANY 연산자
--하나이상만 만족하면 된다.
--최소값보다 크면 참이된다. MIN(FID)

SELECT ENAME, SAL
FROM EMP
WHERE SAL>ANY(SELECT SAL
			FROM EMP
			WHERE DEPTNO=30);

SELECT ENAME, SAL
FROM EMP
WHERE SAL>(SELECT MIN(SAL)
		FROM EMP
		WHERE DEPTNO=30);

--254P 10번
SELECT ENAME, SAL
FROM EMP
WHERE SAL> ANY(SELECT SAL
			FROM EMP
			WHERE JOB = 'SALESMAN')
		AND JOB<>'SALESMAN';
			
--254P 11번
SELECT ENAME, JOB
FROM EMP
WHERE JOB = ANY (SELECT JOB
				FROM EMP
				WHERE ENAME='SMITH');
--254P 12번
SELECT ENAME, SAL
FROM EMP
WHERE SAL> ALL( SELECT SAL
			FROM EMP
			WHERE JOB='SALESMAN'
			)
	AND DEPTNO <>20;
	
--254P 13번
SELECT ENAME,SAL
FROM EMP
WHERE SAL>ANY(SELECT SAL
			FROM EMP
			WHERE JOB='SALESMAN')
	AND DEPTNO<>20;

